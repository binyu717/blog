(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{406:function(r,i,e){"use strict";e.r(i);var t=e(54),n=Object(t.a)({},(function(){var r=this,i=r.$createElement,e=r._self._c||i;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h2",{attrs:{id:"推荐"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#推荐"}},[r._v("#")]),r._v(" 推荐")]),r._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://yq.aliyun.com/articles/29122",target:"_blank",rel:"noopener noreferrer"}},[r._v("存储与持久化操作配置详细解析"),e("OutboundLink")],1)])]),r._v(" "),e("h2",{attrs:{id:"基本概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#基本概念"}},[r._v("#")]),r._v(" 基本概念")]),r._v(" "),e("ul",[e("li",[r._v("Quartz有3个核心：调度器、任务、触发器（一个任务可以关联多个触发器，二一个触发器只能触发一个任务）")]),r._v(" "),e("li",[r._v("当Scheduler调度JOb的时候，实际上会通过反射newInstance一个人新的Job实例，在调度完后再进行销毁，同时会把JobExecutionContext传递给Job的execute方法，Job实例通过JobExecutionContext访问到Quartz运行时的环境以及Job本身的明细数据。")]),r._v(" "),e("li",[r._v("Trigger 有两种：SimpleTrigger/CronTrigger")]),r._v(" "),e("li",[r._v("Quartz属性文件，项目初始化时会自动加载quartz.propertiers文件，若找不到会使用quartz.jar的默认quartz.propertiers文件")])]),r._v(" "),e("h2",{attrs:{id:"quartz-的-misfire处理规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#quartz-的-misfire处理规则"}},[r._v("#")]),r._v(" Quartz 的 Misfire处理规则:")]),r._v(" "),e("h3",{attrs:{id:"调度-schedulejob-或恢复调度-resumetrigger-resumejob-后不同的misfire对应的处理规则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#调度-schedulejob-或恢复调度-resumetrigger-resumejob-后不同的misfire对应的处理规则"}},[r._v("#")]),r._v(" 调度(scheduleJob)或恢复调度(resumeTrigger,resumeJob)后不同的misfire对应的处理规则")]),r._v(" "),e("h4",{attrs:{id:"crontrigger"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#crontrigger"}},[r._v("#")]),r._v(" CronTrigger")]),r._v(" "),e("ul",[e("li",[e("p",[r._v("withMisfireHandlingInstructionDoNothing"),e("br"),r._v("\n——不触发立即执行"),e("br"),r._v("\n——等待下次Cron触发频率到达时刻开始按照Cron频率依次执行")])]),r._v(" "),e("li",[e("p",[r._v("withMisfireHandlingInstructionIgnoreMisfires"),e("br"),r._v("\n——以错过的第一个频率时间立刻开始执行"),e("br"),r._v("\n——重做错过的所有频率周期后"),e("br"),r._v("\n——当下一次触发频率发生时间大于当前时间后，再按照正常的Cron频率依次执行")])]),r._v(" "),e("li",[e("p",[r._v("withMisfireHandlingInstructionFireAndProceed"),e("br"),r._v("\n——以当前时间为触发频率立刻触发一次执行"),e("br"),r._v("\n——然后按照Cron频率依次执行")])])]),r._v(" "),e("h4",{attrs:{id:"simpletrigger"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#simpletrigger"}},[r._v("#")]),r._v(" SimpleTrigger")]),r._v(" "),e("ul",[e("li",[e("p",[r._v("withMisfireHandlingInstructionFireNow"),e("br"),r._v("\n——以当前时间为触发频率立即触发执行"),e("br"),r._v("\n——执行至FinalTIme的剩余周期次数"),e("br"),r._v("\n——以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到"),e("br"),r._v("\n——调整后的FinalTime会略大于根据starttime计算的到的FinalTime值")])]),r._v(" "),e("li",[e("p",[r._v("withMisfireHandlingInstructionIgnoreMisfires"),e("br"),r._v("\n——以错过的第一个频率时间立刻开始执行"),e("br"),r._v("\n——重做错过的所有频率周期"),e("br"),r._v("\n——当下一次触发频率发生时间大于当前时间以后，按照Interval的依次执行剩下的频率"),e("br"),r._v("\n——共执行RepeatCount+1次")])]),r._v(" "),e("li",[e("p",[r._v("withMisfireHandlingInstructionNextWithExistingCount"),e("br"),r._v("\n——不触发立即执行"),e("br"),r._v("\n——等待下次触发频率周期时刻，执行至FinalTime的剩余周期次数"),e("br"),r._v("\n——以startTime为基准计算周期频率，并得到FinalTime"),e("br"),r._v("\n——即使中间出现pause，resume以后保持FinalTime时间不变")])]),r._v(" "),e("li",[e("p",[r._v("withMisfireHandlingInstructionNowWithExistingCount"),e("br"),r._v("\n——以当前时间为触发频率立即触发执行"),e("br"),r._v("\n——执行至FinalTIme的剩余周期次数"),e("br"),r._v("\n——以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到"),e("br"),r._v("\n——调整后的FinalTime会略大于根据starttime计算的到的FinalTime值")])]),r._v(" "),e("li",[e("p",[r._v("withMisfireHandlingInstructionNextWithRemainingCount"),e("br"),r._v("\n——不触发立即执行"),e("br"),r._v("\n——等待下次触发频率周期时刻，执行至FinalTime的剩余周期次数"),e("br"),r._v("\n——以startTime为基准计算周期频率，并得到FinalTime"),e("br"),r._v("\n——即使中间出现pause，resume以后保持FinalTime时间不变")])]),r._v(" "),e("li",[e("p",[r._v("withMisfireHandlingInstructionNowWithRemainingCount"),e("br"),r._v("\n——以当前时间为触发频率立即触发执行"),e("br"),r._v("\n——执行至FinalTIme的剩余周期次数"),e("br"),r._v("\n——以调度或恢复调度的时刻为基准的周期频率，FinalTime根据剩余次数和当前时间计算得到"),e("br"),r._v("\n——调整后的FinalTime会略大于根据starttime计算的到的FinalTime值")])]),r._v(" "),e("li",[e("p",[r._v("MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT"),e("br"),r._v("\n——此指令导致trigger忘记原始设置的starttime和repeat-count"),e("br"),r._v("\n——触发器的repeat-count将被设置为剩余的次数"),e("br"),r._v("\n——这样会导致后面无法获得原始设定的starttime和repeat-count值")])])])])}),[],!1,null,null,null);i.default=n.exports}}]);