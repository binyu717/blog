(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{410:function(a,e,i){"use strict";i.r(e);var n=i(54),r=Object(n.a)({},(function(){var a=this,e=a.$createElement,i=a._self._c||e;return i("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[i("h1",{attrs:{id:"spring学习笔记"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#spring学习笔记"}},[a._v("#")]),a._v(" Spring学习笔记")]),a._v(" "),i("h2",{attrs:{id:"《spring实战》"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#《spring实战》"}},[a._v("#")]),a._v(" 《Spring实战》")]),a._v(" "),i("h3",{attrs:{id:"二、-装配bean"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#二、-装配bean"}},[a._v("#")]),a._v(" 二、 装配Bean")]),a._v(" "),i("h4",{attrs:{id:"_2-2-自动化装配bean"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-自动化装配bean"}},[a._v("#")]),a._v(" 2.2 自动化装配Bean")]),a._v(" "),i("p",[a._v("Spring从两个角度来实现自动化装配：")]),a._v(" "),i("ul",[i("li",[a._v("组件扫描（component scanning）：Spring会自动发现应用上下文中所创建的bean。")]),a._v(" "),i("li",[a._v("自动装配（autowiring）：Spring自动满足bean之间的依赖。")])]),a._v(" "),i("p",[a._v("@ContextConfiguration，spring整合JUnit4测试时，使用注解引入多个配置文件")]),a._v(" "),i("ul",[i("li",[a._v("单个文件"),i("br"),a._v('\n@ContextConfiguration(locations="../applicationContext.xml")\n@ContextConfiguration(classes = SimpleConfiguration.class)')])]),a._v(" "),i("p",[a._v("@RunWith 运行器")]),a._v(" "),i("ul",[i("li",[a._v("@RunWith(JUnit4.class)就是指用JUnit4来运行")]),a._v(" "),i("li",[a._v("@RunWith(SpringJUnit4ClassRunner.class),让测试运行于Spring测试环境")]),a._v(" "),i("li",[a._v("@RunWith(Suite.class)的话就是一套测试集合")])]),a._v(" "),i("p",[a._v("@ComponentScan 按照默认规则，它会以配置类所在的包作为基础包（base package）来扫描组件")]),a._v(" "),i("ul",[i("li",[a._v('通过@ComponentScan的value属性指明包的名称 eg:@ComponentScan("com.base")')]),a._v(" "),i("li",[a._v('通过basePackages属性进行配置,可以指定多个 eg:@ComponentScan(basePackages = "com.base")、@ComponentScan(basePackages = {"com.base","com.biz"})')]),a._v(" "),i("li",[a._v("指定为包中所包含的类或接口,这些类所在的包将会作为组件扫描的基础包，一样可以指定多个 eg:@ComponentScan(basePackageClasses = Demo.class)")])]),a._v(" "),i("h4",{attrs:{id:"_2-3-通过java代码装配bean"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-通过java代码装配bean"}},[a._v("#")]),a._v(" 2.3 通过Java代码装配bean")]),a._v(" "),i("ul",[i("li",[a._v("@Configuration注解表明这个类是一个配置类")]),a._v(" "),i("li",[a._v("声明简单的bean")]),a._v(" "),i("li",[a._v("借助JavaConfig实现注入")])]),a._v(" "),i("h4",{attrs:{id:"_2-4-通过xml装配bean"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-通过xml装配bean"}},[a._v("#")]),a._v(" 2.4　通过XML装配bean")]),a._v(" "),i("ul",[i("li",[a._v("bean元素,类似于JavaConfig中的@Bean注解")]),a._v(" "),i("li",[a._v("借助构造器注入初始化bean\n"),i("ul",[i("li"),a._v(" "),i("li",[a._v("使用Spring 3.0所引入的c-命名空间")])])])]),a._v(" "),i("h3",{attrs:{id:"三、高级装配"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#三、高级装配"}},[a._v("#")]),a._v(" 三、高级装配")]),a._v(" "),i("h4",{attrs:{id:"_3-1-环境与profile"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-环境与profile"}},[a._v("#")]),a._v(" 3.1 环境与profile")]),a._v(" "),i("h5",{attrs:{id:"_3-1-1配置profile-bean"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-1配置profile-bean"}},[a._v("#")]),a._v(" 3.1.1配置profile bean")]),a._v(" "),i("ul",[i("li",[a._v("在Java配置中，可以使用@Profile注解指定某个bean属于哪一个profile，它会告诉Spring这个配置类中的\nbean只有在dev profile激活时才会创建。")]),a._v(" "),i("li",[a._v("在XML中配置profile：通过"),i("beans",[a._v("元素的profile属性，在XML中配置profile bean。")])],1)]),a._v(" "),i("h5",{attrs:{id:"_3-1-2激活profile"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-2激活profile"}},[a._v("#")]),a._v(" 3.1.2激活profile")]),a._v(" "),i("p",[a._v("Spring在确定哪个profile处于激活状态时，需要依赖两个独立的属\n性：spring.profiles.active和spring.profiles.default。如果设置了\nspring.profiles.active属性的话，那么它的值就会用来确定哪个profile是激活的。但\n如果没有设置spring.profiles.active属性的话，那Spring将会查\n找spring.profiles.default的值。如果spring.profiles.active和\nspring.profiles.default均没有设置的话，那就没有激活的profile，因此只会创建那\n些没有定义在profile中的bean。")]),a._v(" "),i("ul",[i("li",[a._v("有多种方式来设置这两个属性：\n"),i("ul",[i("li",[a._v("作为DispatcherServlet的初始化参数；")]),a._v(" "),i("li",[a._v("作为Web应用的上下文参数；")]),a._v(" "),i("li",[a._v("作为JNDI条目；")]),a._v(" "),i("li",[a._v("作为环境变量；")]),a._v(" "),i("li",[a._v("作为JVM的系统属性；")]),a._v(" "),i("li",[a._v("在集成测试类上，使用@ActiveProfiles注解设置。")])])]),a._v(" "),i("li",[a._v("Spring提供了@ActiveProfiles注解，我们可以使用它来指定运行测试时要激活哪个profile")])]),a._v(" "),i("h4",{attrs:{id:"_3-2-条件化的bean"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-条件化的bean"}},[a._v("#")]),a._v(" 3.2　条件化的bean")]),a._v(" "),i("h4",{attrs:{id:"_3-3-处理自动装配的歧义性"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-处理自动装配的歧义性"}},[a._v("#")]),a._v(" 3.3　处理自动装配的歧义性")]),a._v(" "),i("ul",[i("li",[a._v("标示首选的bean:通过@Primary来表达最喜欢的方案，@Primary能够与@Component组合用在组件扫描的bean上，")]),a._v(" "),i("li",[a._v('限定自动装配的bean，@Qualifier注解是使用限定符的主要方式，@Qualifier("iceCream")')])]),a._v(" "),i("h4",{attrs:{id:"_3-4-bean的作用域"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#_3-4-bean的作用域"}},[a._v("#")]),a._v(" 3.4　bean的作用域")]),a._v(" "),i("ul",[i("li",[a._v("Spring定义了多种作用域\n"),i("ul",[i("li",[a._v("单例（Singleton）：在整个应用中，只创建bean的一个实例。")]),a._v(" "),i("li",[a._v("原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。")]),a._v(" "),i("li",[a._v("会话（Session）：在Web应用中，为每个会话创建一个bean实例。")]),a._v(" "),i("li",[a._v("请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。")])])]),a._v(" "),i("li",[a._v("单例是默认的作用域，可使用@Scope注解，它可以与@Component或@Bean一起使用")])]),a._v(" "),i("h3",{attrs:{id:"四-面向切面的spring"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#四-面向切面的spring"}},[a._v("#")]),a._v(" 四 面向切面的Spring")]),a._v(" "),i("ul",[i("li",[a._v("横切关注点可以被描述为影响应用多处的功能。")]),a._v(" "),i("li",[a._v("通知（Advice)\n"),i("ul",[i("li",[a._v("前置通知（Before）：在目标方法被调用之前调用通知功能；")]),a._v(" "),i("li",[a._v("后置通知（After）：在目标方法完成之后调用通知，此时不会关心方法的输出是什么；")]),a._v(" "),i("li",[a._v("返回通知（After-returning）：在目标方法成功执行之后调用通知；")]),a._v(" "),i("li",[a._v("异常通知（After-throwing）：在目标方法抛出异常后调用通知；")]),a._v(" "),i("li",[a._v("环绕通知（Around）：通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为")])])])]),a._v(" "),i("h3",{attrs:{id:"五-构建spring-web应用程序"}},[i("a",{staticClass:"header-anchor",attrs:{href:"#五-构建spring-web应用程序"}},[a._v("#")]),a._v(" 五 构建Spring Web应用程序")])])}),[],!1,null,null,null);e.default=r.exports}}]);